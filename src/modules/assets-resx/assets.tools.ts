import * as fs from 'fs';

import { Asset, AssetsMap } from "../../dinovel";
import { MergeAssetOptions, MergeAssetsResult } from '../../models';
import { buildAsset, getWorkspaceFolder, listAllFiles, getWorkspaceFile, DynVariable } from "../../utils";
import { DinovelEvents } from '../../infra/events';

export const DinovelAssets = new DynVariable<AssetsMap>(
  {},
  () => readAssetMap(),
  DinovelEvents.assets
);

const START = 'export const GAME_ASSETS: AssetsMap =';
const END = ';';

/**
 * Read all files in assets folder and merge them with assets.map.ts file.
 *
 * @param appRoot workspace root
 * @param options Merge options
 * @returns Merge result
 */
export function reloadAssets(appRoot?: string, options?: MergeAssetOptions): MergeAssetsResult {
  const opt = options || {};
  opt.appRoot = opt.appRoot ?? appRoot;

  const toUpdate = listAssets(appRoot);
  const current = readAssetMap(appRoot);
  const merge = mergeAssets(toUpdate, current, opt);

  const hasChanges = merge.added + merge.updated + merge.deleted > 0;
  if (hasChanges) {
    writeAssetMap(merge.result, appRoot);
  }

  return merge;
}

/**
 * Update assets
 *
 * @param list Assets to update
 * @param appRoot workspace root
 */
export function updateAssets(list: Asset[], appRoot?: string): void {
  const map = readAssetMap(appRoot);
  for (const a of list) {
    map[a.id] = a;
  }
  writeAssetMap(map, appRoot);
}

/**
 * List all available assets in the given folder.
 *
 * @param appRoot workspace root
 * @returns List of assets in the workspace
 */
export function listAssets(appRoot?: string): Asset[] {
  const assetsFolder = getWorkspaceFolder('assets', appRoot);

  return listAllFiles(assetsFolder)
    .map(f => buildAsset(f.path, assetsFolder));
}

/**
 * Read assets.map.ts file from the given folder.
 *
 * @param appRoot workspace root
 * @returns Assets map
 */
export function readAssetMap(appRoot?: string): AssetsMap {
  const mapFile = getWorkspaceFile('assetMap', appRoot);
  if (!fs.existsSync(mapFile)) { return {}; }

  const textContent = fs.readFileSync(mapFile, 'utf8');

  let start = textContent.indexOf(START) + START.length;
  let end = textContent.lastIndexOf(END);

  if (start < 0 || end < 0) { return {}; }

  const content = textContent.substring(start, end);
  return JSON.parse(content);
}

/**
 * Craete/udpate assets.map.ts file to the given folder.
 *
 * @param map Assets map to write
 * @param appRoot workspace root
 */
export function writeAssetMap(map: AssetsMap, appRoot?: string): void {
  const mapFile = getWorkspaceFile('assetMap', appRoot, true);
  const header = '// IMPORTANT: This file is auto-generated by dinovel. Do not edit it manually.\n';
  const importStatement = `${header}import { AssetsMap } from 'dinovel/modules/assets.ts';\n\n`;
  const textContent = `${importStatement}${START} ${JSON.stringify(map, null, 2)}${END}`;
  fs.writeFileSync(mapFile, textContent, { encoding: 'utf8' });
}

/**
 * Merge a collections of assets into the current assets.
 *
 * @param assets List of assets to merge
 * @param map Current assets map
 * @param options Merge options
 * @returns Merged assets map and stats
 */
export function mergeAssets(assets: Asset[], map: AssetsMap, options?: MergeAssetOptions): MergeAssetsResult {
  const current = Object.values(map);
  const opt: MergeAssetOptions = options ?? {};
  const needUpdate = opt.updateCategory || opt.updateTags || opt.updateType || false;

  const res: MergeAssetsResult = {
    result: {},
    added: 0,
    deleted: 0,
    unchanged: 0,
    updated: 0
  };

  for (const a of assets) {
    const og = current.find(c => c.path === a.path);
    addToMap(res, a, og, opt, needUpdate);
  }

  const toDelete = current.filter(c => !assets.find(a => a.path === c.path));
  if (opt.keepMissing) {
    for (const d of toDelete) {
      res.result[d.id] = d;
    }
  } else {
    res.deleted = toDelete.length;
  }

  return res;
}

function mergeAsset(og: Asset, n: Asset, opt: MergeAssetOptions): [Asset, boolean] {
  let changed = false;
  const res: Asset = { ...og };

  if (opt.updateTags) {
    const nTags = new Set([...n.tags, ...og.tags]);
    if (nTags.size !== og.tags.length) {
      res.tags = [...nTags];
      changed = true;
    }
  }

  if (opt.updateCategory && n.category !== og.category) {
    res.category = n.category;
    changed = true;
  }

  if (opt.updateType && n.type !== og.type) {
    res.type = n.type;
    changed = true;
  }

  return [res, changed];
}

function addToMap(res: MergeAssetsResult, a: Asset, og: Asset | undefined, opt: MergeAssetOptions, update: boolean): void {
  let status: keyof MergeAssetsResult = 'added';
  if (og && update) {
    const [newAsset, changed] = mergeAsset(og, a, opt);
    status = changed ? 'updated' : 'unchanged';
    res.result[newAsset.id] = newAsset;
  } else if(og) {
    status = 'unchanged';
    res.result[og.id] = og;
  } else {
    res.result[a.id] = a;
  }
  res[status]++;
}
